{
  "contracts": [
    {
      "id": "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
      "title": "Balancer V2 Vault",
      "description": "The `Vault` is Balancer V2's core contract. A single instance of it exists for each network, and it is the entity used to interact with Pools by Liquidity Providers who join and exit them, traders who swap, and asset managers who withdraw and deposit tokens.",
      "readMethods": [
        {
          "methodName": "getTotalTokenValueLocked",
          "methodDescription": "Get total token value locked",
          "methodVariables": [
            {
              "name": "userAddress",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "getTokenBalance",
          "methodDescription": "Get token balance for an address",
          "methodVariables": [
            {
              "name": "userAddress",
              "type": "address"
            },
            {
              "name": "tokenAddress",
              "type": "address"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "depositTokens",
          "methodDescription": "Deposit tokens",
          "methodVariables": [
            {
              "name": "amount",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "withdrawTokens",
          "methodDescription": "Withdraw tokens",
          "methodVariables": [
            {
              "name": "amount",
              "type": "uint256"
            }
          ]
        }
      ]
    },
    {
      "id": "0x6048A8c631Fb7e77EcA533Cf9C29784e482391e7",
      "title": "AuthorizerWithAdaptorValidation",
      "description": "The AuthorizerWithAdaptorValidation is an upgrade that fixes an issue in the AuthorizerAdaptor and allows usage of the AuthorizerAdaptorEntrypoint for contract interactions. The primary Authorizer is the one that keeps track of permissions. This is the placeholder for a TimelockAuthorizer, which has yet to developed.",
      "readMethods": [
        {
          "methodName": "canPerform ",
          "methodDescription": "Checks if an address is able to perform an action.",
          "methodVariables": [
            {
              "name": "actionId",
              "type": "bytes32"
            },
            {
              "name": "account",
              "type": "address"
            },
            {
              "name": "where",
              "type": "address"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "None",
          "methodDescription": "None",
          "methodVariables":[
            {
              "name": "None",
              "type": "None"
            }
          ]
        }
      ]
    },
    {
      "id": "0xA331D84eC860Bf466b4CdCcFb4aC09a1B43F3aE6",
      "title": "Authorizer",
      "description": "The Authorizer manages, grants, and revokes, permissions to allow interactions with the infrastructure contracts of Balancer. The Authorizer keeps track of what contracts (primarily multisigs) are allowed to perform actions if they have the role with the same, single action identifier.",
      "readMethods": [
        {
          "methodName": "canPerform ",
          "methodDescription": "Checks if an address is able to perform an action.",
          "methodVariables": [
            {
              "name": "actionId",
              "type": "bytes32"
            },
            {
              "name": "account",
              "type": "address"
            },
            {
              "name": "input",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "getRoleAdmin",
          "methodDescription": "Checks the contract which corresponds to a role.",
          "methodVariables": [
            {
              "name": "role",
              "type": "bytes32"
            }
          ]
        },
        {
          "methodName": "getRoleMember",
          "methodDescription": "Checks the role and position number it was granted to return an address.",
          "methodVariables": [
            {
              "name": "role",
              "type": "bytes32"
            },
            {
              "name": "index",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "getRoleMemberCount",
          "methodDescription": "Checks the amount of contracts have a specific role.",
          "methodVariables": [
            {
              "name": "role",
              "type": "bytes32"
            }
          ]
        },
        {
          "methodName": "hasRole",
          "methodDescription": "Checks is and address has specific role, returns true or false.",
          "methodVariables": [
            {
              "name": "role",
              "type": "bytes32"
            },
            {
              "name": "account",
              "type": "address"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "grantRole",
          "methodDescription": "Grants a single role to a single address",
          "methodVariables": [
            {
              "name": "role",
              "type": "bytes32"
            },
            {
              "name": "account",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "grantRoles",
          "methodDescription": "Grants multiple roles to a single address",
          "methodVariables": [
            {
              "name": "roles",
              "type": "bytes32[]"
            },
            {
              "name": "account",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "grantRolesToMany",
          "methodDescription": "Grants multiple roles to a multiple addresses",
          "methodVariables": [
            {
              "name": "roles",
              "type": "bytes32[]"
            },
            {
              "name": "accounts",
              "type": "address[]"
            }
          ]
        },
        {
          "methodName": "renounceRole",
          "methodDescription": "Revokes a single role from a single address, caller is the address itself.",
          "methodVariables": [
            {
              "name": "role",
              "type": "bytes32"
            },
            {
              "name": "account",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "revokeRole",
          "methodDescription": "Revokes a single role from a single address",
          "methodVariables": [
            {
              "name": "role",
              "type": "bytes32"
            },
            {
              "name": "account",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "revokeRoles",
          "methodDescription": "Revokes multiple roles from a single address",
          "methodVariables": [
            {
              "name": "roles",
              "type": "bytes32[]"
            },
            {
              "name": "account",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "revokeRolesToMany",
          "methodDescription": "Revokes multiple roles from multiple addresses",
          "methodVariables": [
            {
              "name": "roles",
              "type": "bytes32[]"
            },
            {
              "name": "accounts",
              "type": "address[]"
            }
          ]
        }
      ]
    },
    {
      "id": "0x8F42aDBbA1B16EaAE3BB5754915E0D06059aDd75",
      "title": "AuthorizerAdaptor",
      "description": "This contract is intended to act as an adaptor between systems which expect a single admin address and the Balancer Authorizer such that the Authorizer may grant/revoke admin powers to unlimited addresses. The permissions the Authorizer can grant are granular such they may be global or specific to a particular contract. When calculating the actionId to call a function on a target contract, it must be calculated as if it were to be called on this adaptor. This can be done by passing the function selector to the `getActionId` function.",
      "readMethods": [
        {
          "methodName": "getActionId",
          "methodDescription": "Passes a action id to return the authorizer bytes32",
          "methodVariables": [
            {
              "name": "selector",
              "type": "bytes4"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "performAction",
          "methodDescription": "Performs an action in the system",
          "methodVariables": [
            {
              "name": "performAction",
              "type": "payableAmount"
            },
            {
              "name": "target",
              "type": "address"
            },
            {
              "name": "data",
              "type": "bytes"
            }
          ]
        }
      ]
    },
    {
      "id": "0xf5dECDB1f3d1ee384908Fbe16D2F0348AE43a9eA",
      "title": "AuthorizerAdaptorEntrypoint",
      "description": "This contract exists as a fix for a critical bug in the `AuthorizerAdaptor` that could lead to escalation of privileges. The Entrypoint contract addresses this by working in combination with `TimelockAuthorizer` so that all Adaptor calls that are not made via the Entrypoint fail, while those that do happen through the Entrypoint check for permissions correctly. ",
      "readMethods": [
        {
          "methodName": "canPerform",
          "methodDescription": "Checks if an address is able to perform an action.",
          "methodVariables": [
            {
              "name": "actionId",
              "type": "bytes32"
            },
            {
              "name": "account",
              "type": "address"
            },
            {
              "name": "input",
              "type": "address"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "performAction",
          "methodDescription": "Performs an action in the system",
          "methodVariables": [
            {
              "name": "performAction",
              "type": "payableAmount"
            },
            {
              "name": "target",
              "type": "address"
            },
            {
              "name": "data",
              "type": "bytes"
            }
          ]
        }
      ]
    },
    {
      "id": "0x97207B095e4D5C9a6e4cfbfcd2C3358E03B90c4A",
      "title": "ProtocolFeePercentagesProvider",
      "description": "The Protocol Fee Percentage Provider has two critical write functions. The purpose is to add new protocol fee types to the Balancer system, and to adjust protocol fees on each type. There are four current types of protocol fees, swap, flash loan, yield, and asset under management.",
      "readMethods": [
        {
          "methodName": "getFeeTypeMaximumPercentage",
          "methodDescription": "Gets the maximum allowable percentage allowed for a specific protocol fee type.",
          "methodVariables": [
            {
              "name": "feeType",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "getFeeTypeName",
          "methodDescription": "Returns the name for a correspond protocol fee type.",
          "methodVariables": [
            {
              "name": "feeType",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "getFeeTypePercentage",
          "methodDescription": "Returns the current percentage for a correspond protocol fee type.",
          "methodVariables": [
            {
              "name": "feeType",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "isValidFeeType",
          "methodDescription": "Returns true or false for if a fee type exists.",
          "methodVariables": [
            {
              "name": "feeType",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "isValidFeeTypePercentage",
          "methodDescription": "Returns true or false for if a specific protcol fee type can be a specific value.",
          "methodVariables": [
            {
              "name": "feeType",
              "type": "uint256"
            },
            {
              "name": "value",
              "type": "uint256"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "registerFeeType",
          "methodDescription": "Registers a new protcol fee type in the system",
          "methodVariables": [
            {
              "name": "feeType",
              "type": "uint256"
            },
            {
              "name": "name",
              "type": "string"
            },
            {
              "name": "maximumValue",
              "type": "uint256"
            },
            {
              "name": "initialValue",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "setFeeTypePercentage",
          "methodDescription": "Set a specific protcol fee type percentage in the system",
          "methodVariables": [
            {
              "name": "feeType",
              "type": "uint256"
            },
            {
              "name": "newValue",
              "type": "uint256"
            }
          ]
        }
      ]
    },
    {
      "id": " 0xce88686553686DA562CE7Cea497CE749DA109f9F",
      "title": "ProtocolFeeCollector",
      "description": "The Protocol Fee Collector is an auxiliary contract to the Vault, deployed by it during construction. It offloads some of the tasks the Vault performs to reduce its overall bytecode size. The current values for all protocol fee percentages are stored here, and any tokens charged as protocol fees are sent to this contract, where they may be withdrawn by authorized entities. All authorization tasks are delegated to the Vault's own Authorizer.",
      "readMethods": [
        {
          "methodName": "getCollectedFeeAmounts",
          "methodDescription": "Returns and array of amounts collected for each token specificed.",
          "methodVariables": [
            {
              "name": "tokens",
              "type": "address[]"
            }
          ]
        },
        {
          "methodName": "getFlashLoanPercentage",
          "methodDescription": "Returns protocol fee on flash loans.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "getSwapFeePercentage",
          "methodDescription": "Returns protocol fee on swaps.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "setFlashLoanFeePercentage",
          "methodDescription": "Sets flash loan protocol fee percentage. It is reccomended not to use this.",
          "methodVariables": [
            {
              "name": "newFlashLoanFeePercentage",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "setSwapFeePercentage",
          "methodDescription": "Sets swap protocol fee percentage. It is reccomended not to use this.",
          "methodVariables": [
            {
              "name": "newSwapFeePercentage",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "withdrawCollectedFees",
          "methodDescription": "Withdraws specific amounts of specific tokens and sends to them to a recipient.",
          "methodVariables": [
            {
              "name": "tokens",
              "type": "address[]"
            },
            {
              "name": "amounts",
              "type": "uint256[]"
            },
            {
              "name": "recipient",
              "type": "address"
            }
          ]
        }
      ]
    },
    {
      "id": " 0x5ef4c5352882b10893b70DbcaA0C000965bd23c5",
      "title": "ProtocolFeeWithdrawer",
      "description": "The Protocol Fees Withdrawer is a safety layer around the Protocol Fees Collector which allows withdrawals of specific tokens to be blocked. This is useful for the case in which tokens which shouldn't be distributed are unexpectedly paid into the Protocol Fees Collector.",
      "readMethods": [
        {
          "methodName": "getDenyListedToken",
          "methodDescription": "Returns a denylisted token address based on position in the denylists index.",
          "methodVariables": [
            {
              "name": "index",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "getDenyListTokenLength",
          "methodDescription": "Returns the length of the denylist. ",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "isWithdrawableToken",
          "methodDescription": "Returns true or false if a token is denylisted.",
          "methodVariables": [
            {
              "name": "token",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "isWithdrawableTokens",
          "methodDescription": "Returns true or false if a single token in an array of tokens is denylisted.",
          "methodVariables": [
            {
              "name": "token",
              "type": "address[]"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "allowlistToken",
          "methodDescription": "Marks the provided token as eligible for withdrawal from the Protocol Fee Collector",
          "methodVariables": [
            {
              "name": "token",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "denylistToken",
          "methodDescription": "Marks the provided token as ineligible for withdrawal from the Protocol Fee Collector",
          "methodVariables": [
            {
              "name": "token",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "withdrawCollectedFees",
          "methodDescription": "Withdraws fees from the Protocol Fee Collector.",
          "methodVariables": [
            {
              "name": "tokens",
              "type": "address[]"
            },
            {
              "name": "amounts",
              "type": "uint256[]"
            },
            {
              "name": "recipient",
              "type": "address"
            }
          ]
        }
      ]
    },
    {
      "id": " 0x94Dd9C6152a2A0BBcB52d3297b723A6F01D5F9f7",
      "title": "Mimic SmartVault",
      "description": "This smart vault from Mimic automates the withdrawing of protocol fees through the protocol fee withdrawer, from the protocol fee collector. Then sells non-BAL tokens for USDC and sends them to the protcol fee multisig.",
      "readMethods": [
        {
          "methodName": "None",
          "methodDescription": "None",
          "methodVariables":[
            {
              "name": "None",
              "type": "None"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "None",
          "methodDescription": "None",
          "methodVariables":[
            {
              "name": "None",
              "type": "None"
            }
          ]
        }
      ]
    },
    {
      "id": " 0x7c68c42De679ffB0f16216154C996C354cF1161B",
      "title": "Protocol Fee Multisig",
      "description": "The protocol fee multisigs core purpose is to take protocol fees and distribute them to the treasury, veBAL holders, and core pool incentives.",
      "readMethods": [
        {
          "methodName": "None",
          "methodDescription": "None",
          "methodVariables":[
            {
              "name": "None",
              "type": "None"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "None",
          "methodDescription": "None",
          "methodVariables":[
            {
              "name": "None",
              "type": "None"
            }
          ]
        }
      ]
    },
    {
      "id": " 0x8AD2512819A7eae1dd398973EFfaE48dafBe8255",
      "title": "veBalFeeInjector",
      "description": "Chainlink automation compatible smart contract to handle streaming of fees to veBAL. Each 2 weeks fees are processed, there is USD and BAL that needs to be dripped into the veBAL fee distributor over 2 weekly injections. This smart contract handles paying in these fees.  It is build such that it receives new funds every 2 weeks after both runs (rendering it empty. New funds should be sent in when Half is true.  Then half will be paid the first run and the rest wll be paid the second run. There are a number of management functions to allow the owner to sweep tokens and/or change how things work.",
      "readMethods": [
        {
        "methodName": "FeeDistributor",
        "methodDescription": "Returns the FeeDistributor address",
        "methodVariables": [        {
          "name": "None",
          "type": "None"
        }
       ]
      },
      {
      "methodName": "getTokens",
      "methodDescription": "Returns tokens veBAL holders receive",
      "methodVariables": [        {
        "name": "None",
        "type": "None"
      }
      ]}],

      "writeMethods": [
        {
          "methodName": "acceptOwnership",
          "methodDescription": "Write by new owner to accept change of ownership",
          "methodVariables": [        {
            "name": "None",
            "type": "None"
          }
          ]
        },
        {
          "methodName": "pause",
          "methodDescription": "Pauses the injection of fees until unpaused.",
          "methodVariables": [        {
            "name": "None",
            "type": "None"
          }
          ]
        },
          {
            "methodName": "performUpkepp",
            "methodDescription": "Performs an upkeep based on the data passed.",
            "methodVariables": [
        {
          "name": "data",
          "type": "bytes"
        }
        ]},
        {
          "methodName": "setKeeperRegistry",
          "methodDescription": "Sets the keeper registry address",
          "methodVariables": [
        {
          "name": "keeperRegistry",
          "type": "address"
        }
      ]},
      {
        "methodName": "setMinAmount",
        "methodDescription": "Set the global minimum amount that all tokens must have in order for upkeep to runNOTE: this is in whole numbers, it is not adjusted for decimals        ",
        "methodVariables": [
        {
          "name": "minAmount",
          "type": "uint256"
        }
      ]},
      {
        "methodName": "setTokens",
        "methodDescription": "Sets the list of fee tokens to operate on",
        "methodVariables": [
        {
          "name": "setTokens",
          "type": "address[]"
        }
      ]}]
     },
     {
      "id": " 0xD3cf852898b21fc233251427c2DC93d3d604F3BB",
      "title": "FeeDistributor",
      "description": "Distributes any tokens transferred to the contract (e.g. Protocol fees and any BAL emissions) among veBAL holders proportionally based on a snapshot of the week at which the tokens are sent to the FeeDistributor contract. Supports distributing arbitrarily many different tokens. In order to start distributing a new token to veBAL holders simply transfer the tokens to the `FeeDistributor` contract and then call `checkpointToken`.",
      "readMethods": [
        {
          "methodName": "getTokensDistributedInWeek",
          "methodDescription": "Returns amount of tokens distributed in a specific week, based on a timestamp.",
          "methodVariables": [
            {
              "name": "token",
              "type": "address"
            },
            {
              "name": "timestamp",
              "type": "uint256"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "checkpoint",
          "methodDescription": "Caches the total supply of veBAL at the beginning of each week. This function will be called automatically before claiming tokens to ensure the contract is properly updated.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "checkpointToken",
          "methodDescription": "Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.",
          "methodVariables": [
            {
              "name": "token",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "checkpointTokens",
          "methodDescription": "Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.",
          "methodVariables": [
            {
              "name": "tokens",
              "type": "address[]"
            }
          ]
        },
        {
          "methodName": "claimToken",
          "methodDescription": "Claims all pending distributions of the provided token for a user.",
          "methodVariables": [
            {
              "name": "token",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "claimTokens",
          "methodDescription": "AClaims a number of tokens on behalf of a user.",
          "methodVariables": [
            {
              "name": "tokens",
              "type": "address[]"
            }
          ]
        },
        {
          "methodName": "depositToken",
          "methodDescription": "Deposits tokens to be distributed in the current week.",
          "methodVariables": [
            {
              "name": "token",
              "type": "address"
            },
            {
              "name": "amount",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "depositTokens",
          "methodDescription": "Deposits tokens to be distributed in the current week. veBalFeeInjector uses this.",
          "methodVariables": [
            {
              "name": "tokens",
              "type": "address[]"
            },
            {
              "name": "amounts",
              "type": "uint256[]"
            }
          ]
        },
        {
          "methodName": "setOnlyCallerCheck",
          "methodDescription": "Enables / disables verification mechanism for caller.",
          "methodVariables": [
            {
              "name": "enabled",
              "type": "bool"
            }
          ]
        },
        {
          "methodName": "setOnlyCallerCheckWithSignature",
          "methodDescription": "Sets the only caller verification based on a specific signature.",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            },
            {
              "name": "enabled",
              "type": "bool"
            },
            {
              "name": "signature",
              "type": "bytes"
            }
          ]
        }
      ]
    },
    {
      "id": "0xC128a9954e6c874eA3d62ce62B468bA073093F25",
      "title": "veBAL",
      "description": "veBAL is the foundation of Balancer's tokenomics and governance structure. It is compromised of a 80BAL/20WETH Liquidity pool tokens, locked for a period from 1-52 weeks. Longer locks results in higher stake.",
      "readMethods": [
        {
          "methodName": "token",
          "methodDescription": "Returns the underlying token used for locking. In this case 80/20 BAL/WETH",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "locked  end",
          "methodDescription": "Returns a timestamp in uint256 for when a user's lock period will end.",
          "methodVariables": [
            {
              "name": "addr",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "balanceOf",
          "methodDescription": "Returns a user's balance at current time, two similar functions be used for specific a timestamp or block.",
          "methodVariables": [
            {
              "name": "addr",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "balanceOf",
          "methodDescription": "Returns a user's balance at current time, two similar functions be used for specific a timestamp or block.",
          "methodVariables": [
            {
              "name": "addr",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "totalSupply",
          "methodDescription": "Returns a token circulating supply of veBAL at current time, two similar functions be used for specific a timestamp or block.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "locked",
          "methodDescription": "Returns a tuple of a users current locked balance and the end of their lock.",
          "methodVariables": [
            {
              "name": "arg",
              "type": "address"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "commit smart wallet checker",
          "methodDescription": "Tells the veBAL system which contract will be used for the Smart Wallet Checking function.",
          "methodVariables": [
            {
              "name": "addr",
              "type": "address"
            },
            {
              "methodName": "apply smart wallet checker",
              "methodDescription": "Updates the smart wallet checker from the previous contract to the newly committed address.",
              "methodVariables": [
                {
                  "name": "None",
                  "type": "None"
                }
          ]
        },
        {
          "methodName": "checkpoint",
          "methodDescription": "Checkpoints the system for to update voting balances across the users.",
          "methodVariables": [
            {
              "name": "addr",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "create lock",
          "methodDescription": "Creates a new lock, converting 80BAL/20WETH to veBAL based on time.",
          "methodVariables": [
            {
              "name": "value",
              "type": "uint256"
            },
            {
              "name": "unlock time",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "increaseamount",
          "methodDescription": "Increases the amount of tokens in your lock, requires a user to have more unlocked 80BAL/20WETH tokens to add.",
          "methodVariables": [
            {
              "name": "value",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "increase unlock time",
          "methodDescription": "Increases the lock time of currently locked tokens, to increase a user's veBAL balance.",
          "methodVariables": [
            {
              "name": "unlock time",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "withdraw",
          "methodDescription": "Withdraws 80BAL/20WETH tokens from the vote escrow locking contract, only used when a lock duration ends.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        } 
      ]
    }]
    },
    {
      "id": "0x7869296Efd0a76872fEE62A058C8fBca5c1c826C",
      "title": "SmartWalletChecker",
      "description": "The Smart Wallet Checker acts as an allowlist mechanism to permit smart contracts to patricipate in the veBAL system. Typically only EOAs are permitted.",
      "readMethods": [
        {
          "methodName": "check",
          "methodDescription": "Checks if an address is allowlisted.",
          "methodVariables": [
            {
              "name": "contractAddress",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "getAllowlistedAddress",
          "methodDescription": "Shows the allowlisted address based on the position in the Smart Wallet Checker's index.",
          "methodVariables": [
            {
              "name": "index",
              "type": "uint256"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "allowlistAddress",
          "methodDescription": "Adds a smart wallet to the allowlist, giving it permission to lock veBAL.",
          "methodVariables": [
            {
              "name": "contractAddress",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "denylistAddress",
          "methodDescription": "Adds a smart wallet to the denylist, revoking it's permission to lock veBAL.",
          "methodVariables": [
            {
              "name": "contractAddress",
              "type": "address"
            }
          ]
        }
      ]
    },
    {
      "id": "0x83E443EF4f9963C77bd860f94500075556668cb8",
      "title": "VotingEscrowRemapper",
      "description": " This contract allows veBAL holders on Ethereum to assign their balance to designated addresses on each L2. This is intended for smart contracts that are not deployed to the same address on all networks. EOA's are expected to either use the same address, or manage delegation on L2 networks themselves. For each network (chainId), we maintain a mapping between local (Ethereum) and remote (L2) addresses. This contract remaps balance queries on remote network addresses to their corresponding local addresses. Users able to call this contract can set their own mappings, or delegate this function to another account if they cannot.",
      "readMethods": [
        {
          "methodName": "getLocalUser",
          "methodDescription": "Returns the address on mainnet that is connceted to an address on a specific L2. Addresses can be different for contract wallets.",
          "methodVariables": [
            {
              "name": "remoteUser",
              "type": "address"
            },
            {
              "name": "chainId",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "getLockeEnd",
          "methodDescription": "Returns the end of an addresses' locking period.",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "getRemoteUser",
          "methodDescription": "Returns the address on a given L2 that is connceted to an address on a Ethereum Mainnet. Addresses can be different for contract wallets.",
          "methodVariables": [
            {
              "name": "localUser",
              "type": "address"
            },
            {
              "name": "chainId",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "getVotingEscorew",
          "methodDescription": "Returns the address of the voting escrow token used in the system, veBAL",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "clearNetworkRemapping",
          "methodDescription": "Clears a local user's mapping for a particular network.",
          "methodVariables": [
            {
              "name": "clearNetworkRemapping",
              "type": "payable"
            },
            {
              "name": "localUser",
              "type": "address"
            },
            {
              "name": "chainId",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "setNetworkRemapping",
          "methodDescription": "Sets up a mapping from `localUser`'s veBAL balance to `remoteUser` for chain `chainId`.",
          "methodVariables": [
            {
              "name": "setNetworkRemapping",
              "type": "payable"
            },
            {
              "name": "localUser",
              "type": "address"
            },
            {
              "name": "remoteUser",
              "type": "address"
            },
            {
              "name": "chainId",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "setNetworkRemappingManager",
          "methodDescription": "Sets an address to manage the mapping for a given local user on their behalf.",
          "methodVariables": [
            {
              "name": "localUser",
              "type": "address"
            },
            {
              "name": "delegate",
              "type": "address"
            }
          ]
        }
      ]
    },
    {
      "id": "0x96484f2aBF5e58b15176dbF1A799627B53F13B6d",
      "title": "OmniVotingEscrowAdaptor",
      "description": " This contract acts as an adaptor contract between `VotingEscrowRemapper` and `OmniVotingEscrow`. Provides the remapper a stable interface to forward requests to the omni voting escrow, while allowing to configure optional parameters and even swap the target omni voting escrow contract.",
      "readMethods": [
        {
          "methodName": "estimateSendUserBalancer",
          "methodDescription": "Normally used to estimate the fee to send a user balance across networks using native or LayerZero fees.",
          "methodVariables": [
            {
              "name": "dstChainId",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "getAdaptorParams",
          "methodDescription": "Returns `adapterParams` parameter used in `estimateSendUserBalance` and `sendUserBalance`.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "getUseZero",
          "methodDescription": "Returns ` useZro` parameter used in `estimateSendUserBalance`.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "getZeroPaymentAddress",
          "methodDescription": "Returns `zroPaymentAddress` parameter used in `sendUserBalance`.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "sendUserBalance",
          "methodDescription": "Forwards `sendUserBalance` call to omni voting escrow.",
          "methodVariables": [
            {
              "name": "sendUserBalance",
              "type": "payable"
            },
            {
              "name": "user",
              "type": "address"
            },
            {
              "name": "dstChainId",
              "type": "uint16"
            },
            {
              "name": "refundAddress",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "setAdapterParams",
          "methodDescription": "Sets `adapterParams` parameter for `estimateSendUserBalance` and `sendUserBalance` when forwarding calls.",
          "methodVariables": [
            {
              "name": "adapterParams",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "setOmniVotingEscrow",
          "methodDescription": "Sets omni voting escrow address. - This step is required before creating any remapping in the `VotingEscrowRemapper`. Omni voting escrow is not set in the constructor to avoid circular dependencies. Emits `OmniVotingEscrowUpdated` event.",
          "methodVariables": [
            {
              "name": "OmniVotingEscrow",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "setUseZero",
          "methodDescription": "Sets ` useZro` parameter for `estimateSendUserBalance` when forwarding calls.",
          "methodVariables": [
            {
              "name": "useZro",
              "type": "bool"
            }
          ]
        },
        {
          "methodName": "setZeroPaymentAddress",
          "methodDescription": "Sets `zroPaymentAddress` parameter for `sendUserBalance` when forwarding calls.",
          "methodVariables": [
            {
              "name": "paymentAddress",
              "type": "address"
            }
          ]
        }
      ]
    },
    {
      "id": "0xE241C6e48CA045C7f631600a0f1403b2bFea05ad",
      "title": "OmniVotingEscrow",
      "description": " The OmniVotingEscrow contract is the hub for cross chain voting balances to be communicated in the veBAL system. For EOAs this works as a direct bridge, for contract wallets, the remapper and adaptor contracts are needed to properly communciate balances.",
      "readMethods": [
        {
          "methodName": "estimateSendTotalBalancer",
          "methodDescription": "Estimates the fee to send the total voting balance across networks using native or LayerZero fees.",
          "methodVariables": [
            {
              "name": "dstChainId",
              "type": "uint256"
            },
            {
              "name": "useZro",
              "type": "bool"
            },
            {
              "name": "adapterParams",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "lzEndpoint",
          "methodDescription": "Returns the layer zero end point where the mainnet information is being sent to.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "minDstGasLookup",
          "methodDescription": "Returns the minimum gas on a destination chain.",
          "methodVariables": [
            {
              "name": "input",
              "type": "uint16"
            },
            {
              "name": "input",
              "type": "uint16"
            }
          ]
        },
        {
          "methodName": "owner",
          "methodDescription": "Returns the owner address of the contract.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "trustedRemoteLookup",
          "methodDescription": "Returns bytes of a trusted remote, related to the address and chain Id.",
          "methodVariables": [
            {
              "name": "input",
              "type": "uint16"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "forceResumeReceive",
          "methodDescription": "Forces the source chain Id and address to receive the streamed information. Used in the case of a pause of the receiving address.",
          "methodVariables": [
            {
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "name": "srcAddress",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "lzReceive",
          "methodDescription": "The LayerZero Endpoint sends a payload for a source address on source chain to send information to be receieved.",
          "methodVariables": [
            {
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "name": "srcAddress",
              "type": "bytes"
            },
            {
              "name": "nonce",
              "type": "uint64"
            },
            {
              "name": "payload",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "nonblockingLzReceive",
          "methodDescription": "Sends a payload for a source address on source chain to send information to be receieved. This acts as error catching, because failed messages block the channel. This is used for retrying failed interactions.",
          "methodVariables": [
            {
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "name": "srcAddress",
              "type": "bytes"
            },
            {
              "name": "nonce",
              "type": "uint64"
            },
            {
              "name": "payload",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "renounceOwnership",
          "methodDescription": "Connect wallet renounces ownership, in the case it is an owner.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "retryMessage",
          "methodDescription": "Retries sending a message per the inputs. Assumes a failed message occurred.",
          "methodVariables": [
            {
              "name": "retryMessage",
              "type": "payableAmount"
            },
            {
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "name": "srcAddress",
              "type": "bytes"
            },
            {
              "name": "nonce",
              "type": "uint64"
            },
            {
              "name": "payload",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "sendTotalSupply",
          "methodDescription": "Sends total supply of voting escrow contract between networks to destination chain based on provided parameters.",
          "methodVariables": [
            {
              "name": "sendTotalSupply",
              "type": "payableAmount"
            },
            {
              "name": "dstChild",
              "type": "uint16"
            },
            {
              "name": "refundAddress",
              "type": "address"
            },
            {
              "name": "zroPaymentAddress",
              "type": "address"
            },
            {
              "name": "adapterParams",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "sendUserBalance",
          "methodDescription": "Sends user balance of voting escrow contract between networks to destination chain based on provided parameters.",
          "methodVariables": [
            {
              "name": "sendUserBalance",
              "type": "payableAmount"
            },
            {
              "name": "localUser",
              "type": "address"
            },
            {
              "name": "dstChild",
              "type": "uint16"
            },
            {
              "name": "refundAddress",
              "type": "address"
            },
            {
              "name": "zroPaymentAddress",
              "type": "address"
            },
            {
              "name": "adapterParams",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "setConfig",
          "methodDescription": "Sets configuration for respective chain Id",
          "methodVariables": [
            {
              "name": "version",
              "type": "uint16"
            },
            {
              "name": "chainId",
              "type": "uint16"
            },
            {
              "name": "configType",
              "type": "uint256"
            },
            {
              "name": "config",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "setMinDstGas",
          "methodDescription": "Sets the minimum gas to be used on a destination chain for bridging data.",
          "methodVariables": [
            {
              "name": "dstChainId",
              "type": "uint16"
            },
            {
              "name": "packetType",
              "type": "uint16"
            },
            {
              "name": "minGas",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "setPrecrime",
          "methodDescription": "Sets precime, typically the 0x000 address",
          "methodVariables": [
            {
              "name": "precrime",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "setReceiveVersion",
          "methodDescription": "Sets the receive version for the sending and receiving contracts to validate between each other.",
          "methodVariables": [
            {
              "name": "version",
              "type": "uint16"
            }
          ]
        },
        {
          "methodName": "setSendVersion",
          "methodDescription": "Sets the send version for the sending and receiving contracts to validate between each other.",
          "methodVariables": [
            {
              "name": "version",
              "type": "uint16"
            }
          ]
        },
        {
          "methodName": "setTrustedRemote",
          "methodDescription": "Sets the the trusted remote, the remote is instrumental in each chain for handling each networks functionality.",
          "methodVariables": [
            {
              "name": "remoteChainId",
              "type": "uint16"
            },
            {
              "name": "path",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "setTrustedRemoteAddress",
          "methodDescription": "Sets the the trusted remote address, the remote address handles each networks functionality, based on the trusted remote.",
          "methodVariables": [
            {
              "name": "remoteChainId",
              "type": "uint16"
            },
            {
              "name": "remoteAddress",
              "type": "bytes"
            }
          ]
        },
        {
          "methodName": "transferOwnership",
          "methodDescription": "Transfers ownership of the Omni Voting Escrow contract from the current to a new user.",
          "methodVariables": [
            {
              "name": "newOwner",
              "type": "address"
            }
          ]
        }
      ]
    },
    {
      "id": "0xE241C6e48CA045C7f631600a0f1403b2bFea05ad",
      "title": "VotingEscrowDelegationProxy",
      "description": " The VotingEscrowDelegationProxy handles the delegation of veBAL between addresses. This permits the system to move to a new delegation mechanism if needed.",
      "readMethods": [
        {
          "methodName": "adjustedBalanceOf",
          "methodDescription": "Gets a users adjusted balance of veBAL including delegations,",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "adjusted balance of",
          "methodDescription": "Gets a users adjusted balance of veBAL including delegations,",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "getDelegationImplementation",
          "methodDescription": "Returns the current delegation implementation contract.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "killDelegation",
          "methodDescription": "Kills the current delegation implementation. For emergency use, and updating the system if need be.",
          "methodVariables": [
            {
              "name": "None",
              "type": "None"
            }
          ]
        },
        {
          "methodName": "setDelegation",
          "methodDescription": "Sets a new delegation implementation address",
          "methodVariables": [
            {
              "name": "delegation",
              "type": "address"
            }
          ]
        }
      ]
    },
    {
      "id": "0x67F8DF125B796B05895a6dc8Ecf944b9556ecb0B",
      "title": "veBoost - Boost Delegation v2",
      "description": "The veBoost contract handles the boosting of user rewards when staking their liquidity positions in gauges to receive emissions. This contract also handles the delegations of boost between contracts.",
      "readMethods": [
        {
          "methodName": "balanceOf",
          "methodDescription": "Gets a users balance of veBAL",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "adjusted balance of",
          "methodDescription": "Gets a users adjusted balance of veBAL including delegations",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "totalSupply",
          "methodDescription": "Returns the current total supply of veBAL",
          "methodVariables": [

          ]
        },
        {
          "methodName": "delegated balance",
          "methodDescription": "Returns the amount of veBAL a user has delegated to others.",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "recevied balance",
          "methodDescription": "Returns the amount of veBAL a user has delegated to them from others.",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "delegable balance",
          "methodDescription": "Returns the amount of veBAL a user can delegate to others.",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "migrated",
          "methodDescription": "Returns true or false if a delegation code has been migrated from v1 to this contract, v2.",
          "methodVariables": [
            {
              "name": "arg",
              "type": "uint256"
            }
          ]
        }
      ],
      "writeMethods": [
        {
          "methodName": "boost",
          "methodDescription": "Delegates veBAL from the writing address to a designated address.",
          "methodVariables": [
            {
              "name": "to",
              "type": "address"
            },
            {
              "name": "amount",
              "type": "uint256"
            },
            {
              "name": "endtime",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "boost",
          "methodDescription": "Delegates veBAL from the writing address to a designated address.",
          "methodVariables": [
            {
              "name": "to",
              "type": "address"
            },
            {
              "name": "amount",
              "type": "uint256"
            },
            {
              "name": "endtime",
              "type": "uint256"
            },
            {
              "name": "from",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "migrate",
          "methodDescription": "Migrates a delegation from v1 veBoost to this contract, v2. ",
          "methodVariables": [
            {
              "name": "token id",
              "type": "uint256"
            }
          ]
        },
        {
          "methodName": "migrate many",
          "methodDescription": "Migrates multiple delegation from v1 veBoost to this contract, v2. ",
          "methodVariables": [
            {
              "name": "token id",
              "type": "uint256[]"
            }
          ]
        },
        {
          "methodName": "checkpointuser",
          "methodDescription": "Checkpoints a user to ensure their veBAL delegation is properly counted in the system.",
          "methodVariables": [
            {
              "name": "user",
              "type": "address"
            }
          ]
        },
        {
          "methodName": "approve",
          "methodDescription": "Approves another contract address to spend, or utilize the write addresses veBAL.",
          "methodVariables": [
            {
              "name": "spender",
              "type": "address"
            },
            {
              "name": "value",
              "type": "uint256"
            }
          ]
        }
      ]
    }
  ]
}
